
'''
The data

240441 time points (rest)
64 electrodes

https://raphaelvallat.com/bandpower.html
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9206021/
https://openneuro.org/datasets/ds003838/versions/1.0.0

'''
import matplotlib.pyplot as plt
import numpy as np
import scipy.signal as sig

import data_loader as dl
import fourier
import constants as const
import spectral_power as sp
import data_processing as dp




# ----------------------------------------- PLOTTING ----------------------------------------------


def save_plot(filename, arr, title = '', xlabel = '', ylabel = '', label = ''):
    #plt.switch_backend('Agg')
    plt.plot(arr, alpha=0.5, label=label)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.legend()
    plt.savefig(const.DIRECTORY + filename + ".png")
 




# ---------------------------------------------- BANDPASS ----------------------------------------------

# Takes raw data, not FFT.
def bandpass_filter(data, low_freq, high_freq, steepness = 3, sampling_rate=const.SAMPLING_RATE):

	sos = sig.butter(steepness, [low_freq * 2/sampling_rate, high_freq * 2/sampling_rate], btype = "bandpass", output = "sos")
	filt_data = sig.sosfilt(sos, data)

	return filt_data


# ---------------------------------------------- PIPELINE ----------------------------------------------


# Creates a 4-dimensional array
def pipeline(subjects, channels, states, waves, start=0, stop=10000, smooth=0):
	
	fft_arr = np.ndarray(shape=( len(subjects),len(channels), len(states), len(waves) ))
	bp_arr = np.ndarray(shape=( len(subjects),len(channels), len(states), len(waves) ))
	power_arr = np.ndarray(shape=( len(subjects),len(channels), len(states), len(waves) ))

	for i in range(len(subjects)):
		subject = subjects[i]

		for j in range(len(channels)):
			channel_name = channels[j]

			for k in range(len(states)):
				state = states[k]

				for m in range(len(waves)):
					wave = waves[m]
					print("\n")
					#print("Analyzing... \nSubject: " + str(subject) + " \nChannel: " + channel_name + " \nState: " + state + " \nWave: " + wave)

					raw_data = dl.get_channel_data(subject, channel_name, state)

					if wave=='alpha':
						bandpass_data = bandpass_filter(raw_data, low_freq=const.ALPHA_MIN, high_freq=const.ALPHA_MAX)
					elif wave=='theta':
						bandpass_data = bandpass_filter(raw_data, low_freq=const.THETA_MIN, high_freq=const.THETA_MAX)

					#fft_data = fourier_transform(raw_data, SAMPLING_RATE, filename=str, title=str, smooth=smooth, label=state)

					if wave == 'alpha':
						fft_arr[i, j, k, m] = fourier.get_alpha_average(raw_data, start, stop)
						bp_arr[i, j, k, m] = fourier.get_alpha_average(bandpass_data, start, stop)


					elif wave == 'theta':
						fft_arr[i, j, k, m] = fourier.get_theta_average(raw_data, start, stop)
						bp_arr[i, j, k, m] = fourier.get_theta_average(bandpass_data, start, stop)
				
					power_arr[i, j, k, m] = sp.relative_band_power(mem_data, const.SAMPLING_RATE, const.SECONDS, wave)

	return fft_arr, bp_arr, power_arr



# Gets a specific data point from an array generated by the pipeline function.
def get_data_point(arr, subjects, channels, states, waves, subject, channel, state, wave):

	
	subject_index = np.where(subjects == subject)[0]
	channel_index = np.where(channels == channel)[0]
	state_index = np.where(states == state)[0]
	wave_index = np.where(waves == wave)[0]

	return arr[subject_index, channel_index, state_index, wave_index][0]


def clear_file(filename):
	f = open(filename, "w")
	f.write('')
	f.close()


def main():

	subjects = np.array([32, 42, 43])
	channels = np.array(["Fz"])
	states = np.array(['rest', 'memory'])
	waves = np.array(['theta'])


	'''

	for subject in subjects:
		mem_data = dl.get_channel_data(subject, 'Fz', 'memory')
		rest_data = dl.get_channel_data(subject, 'Fz', 'rest')

		filt_mem_data = bandpass_filter(mem_data, const.THETA_MIN, const.THETA_MAX)
		filt_rest_data = bandpass_filter(rest_data, const.THETA_MIN, const.THETA_MAX)


		mem_power = sp.relative_band_power(filt_mem_data, const.SAMPLING_RATE, 'theta')
		rest_power = sp.relative_band_power(filt_rest_data, const.SAMPLING_RATE, 'theta')

		print("M: ", mem_power)
		print("R: ", rest_power)
		
		sp.plot_spectral_power(filt_mem_data, 'memory' + str(subject), const.SAMPLING_RATE, label='memory', newFig = False)
		sp.plot_spectral_power(filt_rest_data, 'rest' + str(subject), const.SAMPLING_RATE, label='rest', newFig = False)
		plt.figure()
	'''


	n_seconds = 3
	CHANNEL = 'Fz'


	for subject in subjects:	# 32, 42, 43

		for state in states:	# 'memory', 'rest'

			data = dl.get_channel_data(subject, CHANNEL, state)
			print(len(data))

			size = n_seconds * const.SAMPLING_RATE

			part_data = dp.partition_array(data, size)

			average = 0
			max_power = 0

			powers = np.empty(len(part_data))

			for i in range(len(part_data)):

				partition = part_data[i]

				filt_data = bandpass_filter(partition, const.THETA_MIN, const.THETA_MAX)

				power = sp.relative_band_power(filt_data, const.SAMPLING_RATE, 'theta')
				#power = fourier.get_theta_average(filt_data, 0, -1)

				print(state, "\tPartition\t", i, "\tMax Power\t", round(max_power, 2))
				average += power

				if power > max_power:
					max_power = power

				powers[i] = power

			average = round(average / len(part_data), 3)
			max_power = round(max_power, 3)

			print("Average relative power\t", state, "\t", average)
			print("Max relative power\t", state, "\t", max_power)

			name = str(subject) + "-" + state + "-" + CHANNEL
			save_plot(name, powers[1:-1], title = name, xlabel = 'Chunk', ylabel = 'Power', label=state)

		plt.figure()


if __name__ == "__main__":
    main()