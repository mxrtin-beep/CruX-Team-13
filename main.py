
'''
The data

240441 time points (rest)
64 electrodes

https://raphaelvallat.com/bandpower.html
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9206021/
https://openneuro.org/datasets/ds003838/versions/1.0.0

'''
import matplotlib.pyplot as plt
import numpy as np

import data_loader_pavlov as dl
import data_loader_wang as wang
import fourier
import constants as const
import spectral_power as sp
import data_processing as dp
import bp_filter as bp
import classify


# ----------------------------------------- PLOTTING ----------------------------------------------


def save_plot(filename, arr, title = '', xlabel = '', ylabel = '', label = ''):
    #plt.switch_backend('Agg')
    plt.plot(arr, alpha=0.5, label=label)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    plt.legend()
    plt.savefig(const.CHART_DIRECTORY + filename + ".png")
 







# ---------------------------------------------- PIPELINE ----------------------------------------------


# Creates a 4-dimensional array
def pipeline(subjects, channels, states, waves, start=0, stop=10000, smooth=0):
	
	fft_arr = np.ndarray(shape=( len(subjects),len(channels), len(states), len(waves) ))
	bp_arr = np.ndarray(shape=( len(subjects),len(channels), len(states), len(waves) ))
	power_arr = np.ndarray(shape=( len(subjects),len(channels), len(states), len(waves) ))

	for i in range(len(subjects)):
		subject = subjects[i]

		for j in range(len(channels)):
			channel_name = channels[j]

			for k in range(len(states)):
				state = states[k]

				for m in range(len(waves)):
					wave = waves[m]
					print("\n")
					#print("Analyzing... \nSubject: " + str(subject) + " \nChannel: " + channel_name + " \nState: " + state + " \nWave: " + wave)

					raw_data = dl.get_channel_data(subject, channel_name, state)

					if wave=='alpha':
						bandpass_data = bp.bandpass_filter(raw_data, low_freq=const.ALPHA_MIN, high_freq=const.ALPHA_MAX)
					elif wave=='theta':
						bandpass_data = bp.bandpass_filter(raw_data, low_freq=const.THETA_MIN, high_freq=const.THETA_MAX)

					#fft_data = fourier_transform(raw_data, SAMPLING_RATE, filename=str, title=str, smooth=smooth, label=state)

					if wave == 'alpha':
						fft_arr[i, j, k, m] = fourier.get_alpha_average(raw_data, start, stop)
						bp_arr[i, j, k, m] = fourier.get_alpha_average(bandpass_data, start, stop)


					elif wave == 'theta':
						fft_arr[i, j, k, m] = fourier.get_theta_average(raw_data, start, stop)
						bp_arr[i, j, k, m] = fourier.get_theta_average(bandpass_data, start, stop)
				
					power_arr[i, j, k, m] = sp.relative_band_power(mem_data, const.SAMPLING_RATE, const.SECONDS, wave)

	return fft_arr, bp_arr, power_arr



# Gets a specific data point from an array generated by the pipeline function.
def get_data_point(arr, subjects, channels, states, waves, subject, channel, state, wave):

	
	subject_index = np.where(subjects == subject)[0]
	channel_index = np.where(channels == channel)[0]
	state_index = np.where(states == state)[0]
	wave_index = np.where(waves == wave)[0]

	return arr[subject_index, channel_index, state_index, wave_index][0]


def clear_file(filename):
	f = open(filename, "w")
	f.write('')
	f.close()


def classify_wang(data):
	
	base_times, base_data = wang.get_channel_data(1, 'Fz', 'eyesopen', 1)

	base = sp.abs_band_power(base_data, const.WANG_SAMPLING_RATE, 'theta', const.WANG_SECONDS)

	return classify.general_classify(data, const.WANG_SAMPLING_RATE, cutoff=(const.CUTOFF*base), n_seconds=const.WANG_SECONDS)


def classify_pavlov(data):
	
	base_data = dl.get_channel_data(42, 'Fz', 'rest')

	base = sp.abs_band_power(base_data, const.PAVLOV_SAMPLING_RATE, 'theta', const.PAVLOV_SECONDS)

	return classify.general_classify(data, const.PAVLOV_SAMPLING_RATE, cutoff=(const.CUTOFF*base), n_seconds=const.PAVLOV_SECONDS)



def main():

	base1 = 8*(10**(-13))
	base2 = 2



	times, data = wang.get_channel_data(1, 'Fz', 'eyesopen', 1)
	classify_wang(data)


	times, data = wang.get_channel_data(1, 'Fz', 'memory', 1)
	classify_wang(data)

	
	data = dl.get_channel_data(42, 'Fz', 'rest')
	classify_pavlov(data)

	data = dl.get_channel_data(42, 'Fz', 'memory')
	classify_pavlov(data)


if __name__ == "__main__":
    main()





    